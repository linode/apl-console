# RedKubes default Workflow
#
# Given facts:
# * We don't allow manual tagging, but let the workflow create them after tests have passed.
# * We don't let workflows be triggered by events coming from tags
# * We use `npm run release` (without automated tagging) which only bumps version and creates changelog and commit message with title 'chore(release): v${semverVersion}'
# * Pipeline detects the release title and after tests pass, creates artifacts (images) and makes full tag copies (and github release) to allow release patching.
name: Build test push release
on:
  push:
    branches:
      - '**'
    tags-ignore:
      - '*'
env:
  COMMIT_MSG: ${{ github.event.head_commit.message }}
  CACHE_REGISTRY: ghcr.io
  CACHE_REPO: redkubes/otomi-console
  REPO: otomi/console
  REG_GCR: eu.gcr.io
  E2E_IMG: eu.gcr.io/otomi-cloud/otomi-e2e:latest
  GIT_USER: redkubesbot
  GIT_PASSWORD: ${{ secrets.GITHUB_TOKEN }}
  DOCKER_PASSWORD: ${{ secrets.DOCKERHUB_OTOMI_TOKEN }}
  PERCY_TOKEN: '${{ secrets.PERCY_TOKEN }}'
  GCLOUD_SERVICE_KEY: '${{ secrets.GCLOUD_SERVICE_KEY }}'

jobs:
  build-test-push-release:
    if: (!startsWith(github.ref, 'refs/tags/'))
    runs-on: ubuntu-latest
    steps:
      - name: Set env
        run: |
          tag=$(echo $(basename $GITHUB_REF))
          echo "Creating tag: $tag"
          echo "TAG=$tag" >> $GITHUB_ENV
      - name: Checkout
        uses: actions/checkout@v3
        with:
          token: ${{ env.GIT_PASSWORD }}
      - name: CI tests, image build and push tag for main or branch
        uses: whoan/docker-build-with-cache-action@v6
        with:
          username: redkubesbot
          password: '${{ secrets.NPM_TOKEN }}'
          registry: ${{ env.CACHE_REGISTRY }}
          image_name: ${{ env.CACHE_REPO }}
          image_tag: ${{ env.TAG }}
          build_extra_args: '--build-arg=NPM_TOKEN=${{ secrets.NPM_TOKEN }}'
      - name: Retag from cache and push
        run: |
          docker login -u otomi -p $DOCKER_PASSWORD
          docker tag $CACHE_REGISTRY/$CACHE_REPO:$TAG $REPO:$TAG
          docker push $REPO:$TAG
      - if: (startsWith(github.ref, 'refs/heads/releases/') || startsWith(github.ref, 'refs/heads/main'))&& startsWith(github.event.head_commit.message, 'chore(release)')
        name: Docker tag and push. Git tag and push.
        id: git_tag
        run: |
          # docker tag $REPO:$TAG $REPO:latest
          # docker push $REPO:latest
          release_tag=v${COMMIT_MSG#* }
          echo tag=$release_tag >> $GITHUB_OUTPUT
          echo "Releasing $REPO:$release_tag"
          docker tag $REPO:$TAG $REPO:$release_tag
          docker push $REPO:$release_tag
          git config --global user.email $GIT_USER@users.noreply.github.com
          git config --global user.name $GIT_USER
          echo "machine github.com login $GIT_USER password $GIT_PASSWORD" > ~/.netrc
          git tag -am "$COMMIT_MSG" $release_tag && git push --follow-tags
          changelog=$(cat CHANGELOG.md | awk -v n=2 '/### \[[0-9]*/&&!--n{exit}{print}')
          # now do some escaping because github does not help us here:
          changelog="${changelog//'%'/'%25'}"
          changelog="${changelog//$'\n'/'%0A'}"
          changelog="${changelog//$'\r'/'%0D'}"
          echo changes=$changelog >> $GITHUB_OUTPUT
      - if: (startsWith(github.ref, 'refs/heads/releases/') || startsWith(github.ref, 'refs/heads/main'))&& startsWith(github.event.head_commit.message, 'chore(release)')
        name: Create GitHub release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.git_tag.outputs.tag }}
          release_name: Release ${{ steps.git_tag.outputs.tag }}
          body: ${{ steps.git_tag.outputs.changes }}
