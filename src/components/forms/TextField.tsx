import KeyboardArrowDown from '@mui/icons-material/KeyboardArrowDown'
import ArrowDropUpIcon from '@mui/icons-material/ExpandLess'
import ArrowDropDownIcon from '@mui/icons-material/ExpandMore'
import { Theme, useTheme } from '@mui/material/styles'
import { IconButton, TextField as MuiTextField, StandardTextFieldProps } from '@mui/material'
import { clamp } from 'ramda'
import * as React from 'react'
import { makeStyles } from 'tss-react/mui'

import { convertToKebabCase } from '../../utils/convertToKebabCase'
import { Box } from '../Box'
import type { BoxProps } from '../Box'
import { CircleProgress } from '../CircleProgress'
import { FormHelperText } from '../FormHelperText'
import { InputAdornment } from '../InputAdornment'
import { InputLabel } from '../InputLabel'
import { TooltipProps } from '../Tooltip'
import { Typography } from '../Typography'

const useStyles = makeStyles()((theme: Theme) => ({
  absolute: {
    position: 'absolute',
  },
  editable: {
    paddingLeft: 1,
    wordBreak: 'keep-all',
  },
  errorText: {
    alignItems: 'center',
    color: '#d63c42',
    display: 'flex',
    left: 5,
    top: 42,
    width: '100%',
  },
  expand: {
    maxWidth: '100%',
  },
  helpWrapper: {
    alignItems: 'flex-end',
    display: 'flex',
    flexWrap: 'wrap',
  },
  helpWrapperContainer: {
    display: 'flex',
    width: '100%',
  },
  helpWrapperTextField: {
    width: '415px',
  },
  helperTextTop: {
    color: theme.palette.cl.text.subTitle,
    marginTop: 0,
  },
  label: {
    fontFamily: 'sans-serif',
  },
  noTransform: {
    transform: 'none',
  },
  root: {
    marginTop: theme.spacing(1),
  },
  input: {
    border: '1px solid #e3e3e3',
  },
  // TODO: This is a temporary fix for new styles to override the MUI styles
  // This should be removed once the new styles are applied to the TextField component
  TempMuiInput: {
    '&.Mui-disabled': {
      backgroundColor: theme.palette.cm.disabledBackground,
      borderColor: theme.palette.cm.disabledBorder,
      color: theme.palette.cm.disabledText,
      '& input': {
        cursor: 'not-allowed',
      },
      opacity: 0.5,
    },
    '&.Mui-error': {
      borderColor: '#d63c42',
    },
    '& .MuiSelect-select': {
      position: 'relative',
      top: 4,
      '&:focus': {
        backgroundColor: 'transparent',
      },
    },
    '&.Mui-focused': {
      '& .select-option-icon': {
        paddingLeft: `30px !important`,
      },
      borderColor: '#108ad6',
      boxShadow: `0 0 2px 1px #d6d6dd`,
    },
    '&.affirmative': {
      borderColor: '#00b050',
    },
    alignItems: 'center',
    backgroundColor: theme.palette.cm.textBox,
    border: `1px solid ${theme.palette.cm.textBoxBorder}`,
    boxSizing: 'border-box',
    paddingLeft: theme.spacing(1),
    color: theme.palette.text.primary,
    lineHeight: 1,
    maxWidth: 416,
    minHeight: 34,
    transition: 'border-color 225ms ease-in-out',
    '& svg': {
      '&:hover': {
        color: '#5bb3ea',
      },
      color: '#838383',
      fontSize: '25px',
      marginRight: '5px',
    },
    '& input::placeholder': {
      color: '#838383',
    },
  },
}))

/**
 * Extend your existing TextField props with optional number-spinner props.
 */
interface SpinnerProps {
  /**
   * Function to call when the up arrow is clicked.
   */
  onIncrement?: () => void
  /**
   * Function to call when the down arrow is clicked.
   */
  onDecrement?: () => void
  /**
   * Optional suffix symbol (e.g. '%') to show before the spinner.
   */
  suffixSymbol?: string
}

interface BaseProps {
  /**
   * className to apply to the underlying TextField component
   */
  className?: string
  /**
   * Props applied to the root element
   */
  containerProps?: BoxProps
  /**
   * Data attributes are applied to the underlying TextField component for testing purposes
   */
  dataAttrs?: Record<string, any>
  /**
   * Applies editable styles
   * @default false
   */
  editable?: boolean
  /**
   * Adds error grouping to TextField
   */
  errorGroup?: string
  /**
   * When defined, makes the input show an error state with the defined text
   */
  errorText?: string
  /**
   * Makes the TextField use 100% of the available width
   * @default false
   */
  expand?: boolean
  /**
   * Makes the error text have the absolute positioning
   * @default false
   */
  hasAbsoluteError?: boolean
  /**
   * Adds optional helper text to the Textfield
   */
  helperText?: string
  /**
   * Placement of the `helperText`
   * @default bottom
   */
  helperTextPosition?: 'bottom' | 'top'
  /**
   * Hides the `label`
   * @default false
   */
  hideLabel?: boolean
  /**
   * Allows you to manually set an htmlFor input id. One will automatically be generated by the `label` if this is unset
   */
  inputId?: string
  /**
   * Displays a loading spinner at the end of the Text Field
   * @default false
   */
  loading?: boolean
  /**
   * The maximum number allowed in TextField. The "type" prop must also be set to `number`
   */
  max?: number | string
  /**
   * The minimum number allowed in TextField. The "type" prop must also be set to `number`
   */
  min?: number | string
  /**
   * Removes the default top margin (16px)
   * @default false
   */
  noMarginTop?: boolean
  /**
   * Adds `(optional)` to the Label
   * @default false
   */
  optional?: boolean
  /**
   * Adds `(required)` to the Label
   */
  required?: boolean
  /**
   * The leading and trailing spacing should be trimmed from the textfield on blur; intended to be used for username, emails, and SSH key input only
   */
  trimmed?: boolean
  value?: Value
  width?: TextboxWidth
  /**
   * If true, places the label to the left of the text field.
   */
  isHorizontalLabel?: boolean
}

type Value = null | number | string | undefined

type TextboxWidth = 'small' | 'medium' | 'large' | 'fullwidth'

interface LabelToolTipProps {
  labelTooltipText?: React.JSX.Element | string
}

interface InputToolTipProps {
  tooltipClasses?: string
  tooltipOnMouseEnter?: React.MouseEventHandler<HTMLDivElement>
  tooltipPosition?: TooltipProps['placement']
  tooltipText?: React.JSX.Element | string
}

interface TextFieldPropsOverrides extends StandardTextFieldProps {
  label: string
}

/**
 * Extend your TextFieldProps to include spinner props.
 */
export type TextFieldProps = BaseProps & TextFieldPropsOverrides & LabelToolTipProps & InputToolTipProps & SpinnerProps

export const TextField = React.forwardRef(function TextField(props: TextFieldProps, ref) {
  const { classes, cx } = useStyles()
  const theme = useTheme()

  const {
    InputLabelProps,
    InputProps,
    SelectProps,
    children,
    className,
    containerProps,
    dataAttrs,
    editable,
    error,
    errorGroup,
    errorText,
    expand,
    hasAbsoluteError,
    helperText,
    helperTextPosition,
    hideLabel,
    inputId,
    label,
    labelTooltipText,
    loading,
    max,
    min,
    noMarginTop,
    onBlur,
    onChange,
    optional,
    required,
    tooltipClasses,
    tooltipOnMouseEnter,
    tooltipPosition,
    tooltipText,
    trimmed,
    type,
    value,
    width = 'medium',
    onIncrement,
    onDecrement,
    suffixSymbol,
    isHorizontalLabel = false,
    ...textFieldProps
  } = props

  const [_value, setValue] = React.useState<Value>(value)

  const widthMap: Record<TextboxWidth, string> = {
    small: '100px',
    medium: '200px',
    large: '400px',
    fullwidth: '100%',
  }

  React.useEffect(() => {
    setValue(value)
  }, [value])

  const handleBlur = (e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    if (trimmed) {
      const trimmedValue = e.target.value.trim()
      e.target.value = trimmedValue
      setValue(trimmedValue)
    }
    if (onBlur) onBlur(e)
  }

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const numberTypes = ['tel', 'number']
    const minAndMaxExist = typeof min === 'number' && typeof max === 'number'
    const cleanedValue =
      minAndMaxExist && numberTypes.some((eachType) => eachType === type) && e.target.value !== ''
        ? clamp(min, max, +e.target.value)
        : e.target.value

    setValue(cleanedValue || '')

    if (onChange) {
      if (e.target.value !== cleanedValue) {
        const clonedEvent = {
          ...e,
          target: e.target.cloneNode(),
        } as React.ChangeEvent<HTMLInputElement>
        clonedEvent.target.value = `${cleanedValue}`
        onChange(clonedEvent)
      } else onChange(e)
    }
  }

  let errorScrollClassName = ''
  if (errorText) errorScrollClassName = errorGroup ? `error-for-scroll-${errorGroup}` : `error-for-scroll`

  const validInputId = inputId || (label ? convertToKebabCase(`${label}`) : undefined)

  // Default handlers if spinner functions arenâ€™t provided.
  const handleDefaultIncrement = () => {
    const current = typeof _value === 'number' ? _value : parseFloat(_value) || 0
    const newVal = current + 1
    setValue(newVal)
    if (onChange) {
      const event = {
        target: { value: newVal.toString() },
      } as React.ChangeEvent<HTMLInputElement>
      onChange(event)
    }
  }

  const handleDefaultDecrement = () => {
    const current = typeof _value === 'number' ? _value : parseFloat(_value) || 0
    const newVal = current - 1
    setValue(newVal)
    if (onChange) {
      const event = {
        target: { value: newVal.toString() },
      } as React.ChangeEvent<HTMLInputElement>
      onChange(event)
    }
  }

  let finalEndAdornment

  if (loading) {
    finalEndAdornment = (
      <InputAdornment position='end'>
        <CircleProgress size='sm' />
      </InputAdornment>
    )
  } else if (type === 'number') {
    finalEndAdornment = (
      <InputAdornment
        position='end'
        sx={{
          display: 'flex',
          flexDirection: 'row',
          alignItems: 'center',
          height: '32px',
        }}
      >
        {suffixSymbol && <Typography sx={{ fontSize: '1.155rem', color: '#838383' }}>{suffixSymbol}</Typography>}
        <Box sx={{ display: 'flex', flexDirection: 'column' }}>
          <IconButton
            sx={{ maxHeight: '13px' }}
            onClick={onIncrement || handleDefaultIncrement}
            size='small'
            disabled={props.disabled}
          >
            <ArrowDropUpIcon fontSize='inherit' sx={{ mr: '0px !important' }} />
          </IconButton>
          <IconButton
            sx={{ maxHeight: '13px' }}
            onClick={onDecrement || handleDefaultDecrement}
            size='small'
            disabled={props.disabled}
          >
            <ArrowDropDownIcon fontSize='inherit' sx={{ mr: '0px !important' }} />
          </IconButton>
        </Box>
      </InputAdornment>
    )
  } else finalEndAdornment = InputProps?.endAdornment

  return (
    <Box
      {...containerProps}
      className={cx(
        {
          [classes.helpWrapper]: Boolean(tooltipText),
          [errorScrollClassName]: !!errorText,
        },
        containerProps?.className,
      )}
      display='flex'
      flexDirection={isHorizontalLabel ? 'row' : 'column'}
      alignItems={isHorizontalLabel ? 'center' : 'flex-start'}
      sx={{
        ...(!noMarginTop && { marginTop: theme.spacing(2) }),
        gap: isHorizontalLabel ? theme.spacing(2) : 0,
      }}
    >
      {!hideLabel && (
        <InputLabel
          className={cx({
            [classes.noTransform]: true,
          })}
          htmlFor={validInputId}
          sx={{
            fontWeight: 500,
            fontSize: '0.875rem',
            color: theme.palette.cl.text.subTitle,
            marginBottom: isHorizontalLabel ? 0 : theme.spacing(1),
            width: isHorizontalLabel ? 250 : 'auto',
            // textAlign: isHorizontalLabel ? 'right' : 'left',
          }}
          data-qa-textfield-label={label}
        >
          {label}
          {/* eslint-disable-next-line no-nested-ternary */}
          {required ? (
            <span className={classes.label}> (required)</span>
          ) : optional ? (
            <span className={classes.label}> (optional)</span>
          ) : null}
        </InputLabel>
      )}

      <Box display='flex' flexDirection='column' sx={{ width: isHorizontalLabel ? 'auto' : '100%' }}>
        {helperText && helperTextPosition === 'top' && (
          <FormHelperText className={classes.helperTextTop} data-qa-textfield-helper-text>
            {helperText}
          </FormHelperText>
        )}
        <div
          className={cx({
            [classes.helpWrapperContainer]: Boolean(tooltipText),
          })}
        >
          <MuiTextField
            {...textFieldProps}
            {...dataAttrs}
            inputRef={ref}
            InputLabelProps={{
              ...InputLabelProps,
              required: false,
              shrink: true,
            }}
            InputProps={{
              endAdornment: finalEndAdornment,
              ...InputProps,
              className: cx(
                'input',
                {
                  [classes.expand]: expand,
                },
                className,
                classes.TempMuiInput,
              ),
              disableUnderline: true,
            }}
            SelectProps={{
              IconComponent: KeyboardArrowDown,
              MenuProps: {
                MenuListProps: { className: 'selectMenuList' },
                PaperProps: { className: 'selectMenuDropdown' },
                anchorOrigin: { horizontal: 'left', vertical: 'bottom' },
                transformOrigin: { horizontal: 'left', vertical: 'top' },
              },
              disableUnderline: true,
              ...SelectProps,
            }}
            className={cx(
              {
                [classes.helpWrapperTextField]: Boolean(tooltipText),
                [classes.root]: true,
              },
              className,
            )}
            error={!!error || !!errorText}
            sx={{ width: widthMap[width] }}
            helperText=''
            /**
             * Set _helperText_ and _label_ to no value because we want to
             * have the ability to put the helper text under the label at the top.
             */
            label=''
            onBlur={handleBlur}
            onChange={handleChange}
            type={type}
            /*
             * Let us explicitly pass an empty string to the input
             * See UserDefinedFieldsPanel.tsx for a verbose explanation why.
             */
            value={_value}
            variant='standard'
          >
            {children}
          </MuiTextField>
        </div>
        {errorText && (
          <FormHelperText
            className={cx({
              [classes.absolute]: editable || hasAbsoluteError,
              [classes.editable]: editable,
              [classes.errorText]: true,
            })}
            data-qa-textfield-error-text={label}
            role='alert'
            sx={{ width: widthMap[width] }}
          >
            {errorText}
          </FormHelperText>
        )}
        {helperText && (helperTextPosition === 'bottom' || !helperTextPosition) && (
          <FormHelperText data-qa-textfield-helper-text sx={{ width: widthMap[width] }}>
            {helperText}
          </FormHelperText>
        )}
      </Box>
    </Box>
  )
})
