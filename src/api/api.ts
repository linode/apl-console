/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * The otomi-stack API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url'
import * as portableFetch from 'portable-fetch'
import { Configuration } from './configuration'

const BASE_PATH = 'https://otomi-stack-api/v1'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface Deployment
 */
export interface Deployment {
  /**
   *
   * @type {number}
   * @memberof Deployment
   */
  id?: number
  /**
   * Deployment status
   * @type {string}
   * @memberof Deployment
   */
  status?: Deployment.StatusEnum
}

/**
 * @export
 * @namespace Deployment
 */
export namespace Deployment {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    InProgress = <any>'in-progress',
    Completed = <any>'completed',
    Failed = <any>'failed',
  }
}

/**
 *
 * @export
 * @interface OpenApiValidationError
 */
export interface OpenApiValidationError {
  /**
   *
   * @type {number}
   * @memberof OpenApiValidationError
   */
  status?: number
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof OpenApiValidationError
   */
  errors?: Array<ValidationError>
}

/**
 *
 * @export
 * @interface OtomiStackError
 */
export interface OtomiStackError {
  /**
   *
   * @type {string}
   * @memberof OtomiStackError
   */
  message?: string
}

/**
 *
 * @export
 * @interface Team
 */
export interface Team {
  /**
   *
   * @type {string}
   * @memberof Team
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Team
   */
  password: string
  /**
   *
   * @type {TeamOidc}
   * @memberof Team
   */
  oidc: TeamOidc
}

/**
 *
 * @export
 * @interface TeamOidc
 */
export interface TeamOidc {
  /**
   *
   * @type {string}
   * @memberof TeamOidc
   */
  clientID?: string
  /**
   *
   * @type {string}
   * @memberof TeamOidc
   */
  clientSecret?: string
}

/**
 *
 * @export
 * @interface Teams
 */
export interface Teams {
  /**
   *
   * @type {Array<Team>}
   * @memberof Teams
   */
  teams?: Array<Team>
}

/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  path?: string
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  errorCode?: string
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  location?: ValidationError.LocationEnum
}

/**
 * @export
 * @namespace ValidationError
 */
export namespace ValidationError {
  /**
   * @export
   * @enum {string}
   */
  export enum LocationEnum {
    Body = <any>'body',
    Path = <any>'path',
  }
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Get deployment
     * @param {number} deploymentId ID of team to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploymentsDeploymentIdGet(deploymentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'deploymentId' is not null or undefined
      if (deploymentId === null || deploymentId === undefined) {
        throw new RequiredError(
          'deploymentId',
          'Required parameter deploymentId was null or undefined when calling deploymentsDeploymentIdGet.',
        )
      }
      const localVarPath = `/deployments/{deploymentId}`.replace(
        `{${'deploymentId'}}`,
        encodeURIComponent(String(deploymentId)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Trigger a deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploymentsPost(options: any = {}): FetchArgs {
      const localVarPath = `/deployments`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get OpenApi document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiDoc(options: any = {}): FetchArgs {
      const localVarPath = `/apiDocs`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get teams collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsGet(options: any = {}): FetchArgs {
      const localVarPath = `/teams`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a team
     * @param {Team} body Team object that needs to be added to the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsPost(body: Team, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling teamsPost.')
      }
      const localVarPath = `/teams`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Team' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete team
     * @param {string} teamId ID of team to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdDelete(teamId: string, options: any = {}): FetchArgs {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling teamsTeamIdDelete.',
        )
      }
      const localVarPath = `/teams/{teamId}`.replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get teams collection
     * @param {string} teamId ID of team to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdGet(teamId: string, options: any = {}): FetchArgs {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling teamsTeamIdGet.',
        )
      }
      const localVarPath = `/teams/{teamId}`.replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Edit a team
     * @param {string} teamId ID of team to return
     * @param {Team} body Team object that contains updated values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdPut(teamId: string, body: Team, options: any = {}): FetchArgs {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling teamsTeamIdPut.',
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling teamsTeamIdPut.')
      }
      const localVarPath = `/teams/{teamId}`.replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Team' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get deployment
     * @param {number} deploymentId ID of team to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploymentsDeploymentIdGet(
      deploymentId: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Deployment> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deploymentsDeploymentIdGet(
        deploymentId,
        options,
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Trigger a deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploymentsPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Deployment> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deploymentsPost(options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get OpenApi document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiDoc(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getApiDoc(options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get teams collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Teams> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).teamsGet(options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Create a team
     * @param {Team} body Team object that needs to be added to the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsPost(body: Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).teamsPost(body, options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Delete team
     * @param {string} teamId ID of team to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdDelete(teamId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).teamsTeamIdDelete(teamId, options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get teams collection
     * @param {string} teamId ID of team to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdGet(teamId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).teamsTeamIdGet(teamId, options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Edit a team
     * @param {string} teamId ID of team to return
     * @param {Team} body Team object that contains updated values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdPut(teamId: string, body: Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).teamsTeamIdPut(teamId, body, options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Get deployment
     * @param {number} deploymentId ID of team to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploymentsDeploymentIdGet(deploymentId: number, options?: any) {
      return DefaultApiFp(configuration).deploymentsDeploymentIdGet(deploymentId, options)(fetch, basePath)
    },
    /**
     * Trigger a deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploymentsPost(options?: any) {
      return DefaultApiFp(configuration).deploymentsPost(options)(fetch, basePath)
    },
    /**
     * Get OpenApi document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiDoc(options?: any) {
      return DefaultApiFp(configuration).getApiDoc(options)(fetch, basePath)
    },
    /**
     * Get teams collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsGet(options?: any) {
      return DefaultApiFp(configuration).teamsGet(options)(fetch, basePath)
    },
    /**
     * Create a team
     * @param {Team} body Team object that needs to be added to the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsPost(body: Team, options?: any) {
      return DefaultApiFp(configuration).teamsPost(body, options)(fetch, basePath)
    },
    /**
     * Delete team
     * @param {string} teamId ID of team to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdDelete(teamId: string, options?: any) {
      return DefaultApiFp(configuration).teamsTeamIdDelete(teamId, options)(fetch, basePath)
    },
    /**
     * Get teams collection
     * @param {string} teamId ID of team to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdGet(teamId: string, options?: any) {
      return DefaultApiFp(configuration).teamsTeamIdGet(teamId, options)(fetch, basePath)
    },
    /**
     * Edit a team
     * @param {string} teamId ID of team to return
     * @param {Team} body Team object that contains updated values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamsTeamIdPut(teamId: string, body: Team, options?: any) {
      return DefaultApiFp(configuration).teamsTeamIdPut(teamId, body, options)(fetch, basePath)
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Get deployment
   * @param {number} deploymentId ID of team to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deploymentsDeploymentIdGet(deploymentId: number, options?: any) {
    return DefaultApiFp(this.configuration).deploymentsDeploymentIdGet(deploymentId, options)(this.fetch, this.basePath)
  }

  /**
   * Trigger a deployment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deploymentsPost(options?: any) {
    return DefaultApiFp(this.configuration).deploymentsPost(options)(this.fetch, this.basePath)
  }

  /**
   * Get OpenApi document
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getApiDoc(options?: any) {
    return DefaultApiFp(this.configuration).getApiDoc(options)(this.fetch, this.basePath)
  }

  /**
   * Get teams collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public teamsGet(options?: any) {
    return DefaultApiFp(this.configuration).teamsGet(options)(this.fetch, this.basePath)
  }

  /**
   * Create a team
   * @param {Team} body Team object that needs to be added to the collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public teamsPost(body: Team, options?: any) {
    return DefaultApiFp(this.configuration).teamsPost(body, options)(this.fetch, this.basePath)
  }

  /**
   * Delete team
   * @param {string} teamId ID of team to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public teamsTeamIdDelete(teamId: string, options?: any) {
    return DefaultApiFp(this.configuration).teamsTeamIdDelete(teamId, options)(this.fetch, this.basePath)
  }

  /**
   * Get teams collection
   * @param {string} teamId ID of team to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public teamsTeamIdGet(teamId: string, options?: any) {
    return DefaultApiFp(this.configuration).teamsTeamIdGet(teamId, options)(this.fetch, this.basePath)
  }

  /**
   * Edit a team
   * @param {string} teamId ID of team to return
   * @param {Team} body Team object that contains updated values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public teamsTeamIdPut(teamId: string, body: Team, options?: any) {
    return DefaultApiFp(this.configuration).teamsTeamIdPut(teamId, body, options)(this.fetch, this.basePath)
  }
}
